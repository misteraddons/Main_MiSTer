#!/usr/bin/env python3
import re

def parse_ini_vars():
    """Parse cfg.cpp to extract ini_vars array data"""
    with open('/mnt/c/Users/Robot/Documents/GitHub/Main_MiSTer-misteraddons/cfg.cpp', 'r') as f:
        content = f.read()
    
    # Extract the ini_vars array content
    start = content.find('const ini_var_t ini_vars[] =')
    end = content.find('};', start)
    ini_vars_section = content[start:end]
    
    # Pattern to match ini_var entries
    # { "NAME", ptr, type, min, max, "DISPLAY_NAME", "DESCRIPTION", CATEGORY, "UNIT", show_in_osd }
    pattern = r'\{\s*"([^"]+)",\s*[^,]+,\s*[^,]+,\s*[^,]+,\s*[^,]+,\s*"([^"]+)",\s*"([^"]+)",\s*(CAT_[^,]+),\s*[^,]+,\s*(true|false)\s*\}'
    
    matches = re.findall(pattern, ini_vars_section, re.MULTILINE | re.DOTALL)
    
    settings = []
    for ini_name, display_name, description, category, requires_reboot in matches:
        settings.append({
            'ini_name': ini_name,
            'display_name': display_name,
            'description': description, 
            'category': category,
            'requires_reboot': requires_reboot == 'true'
        })
    
    return settings

def analyze_by_category():
    """Analyze settings by category and find longest names"""
    settings = parse_ini_vars()
    
    # List of settings that should appear in OSD menu (from old osd_settings.cpp)
    osd_settings = {
        'COMPOSITE_SYNC', 'DIRECT_VIDEO', 'DVI_MODE', 'FB_SIZE', 'FB_TERMINAL', 
        'FONT', 'FORCED_SCANDOUBLER', 'HDMI_AUDIO_96K', 'HDMI_LIMITED', 
        'KEYRAH_MODE', 'MENU_PAL', 'VGA_SCALER', 'VGA_SOG', 'VIDEO_MODE', 
        'VIDEO_MODE_NTSC', 'VIDEO_MODE_PAL', 'YPBPR'
    }
    
    # Group by category, filtering for OSD-visible settings
    categories = {}
    for setting in settings:
        if setting['ini_name'] in osd_settings:  # Only include settings that appear in OSD
            cat = setting['category']
            if cat not in categories:
                categories[cat] = []
            categories[cat].append(setting)
    
    # Calculate longest display name per category
    category_info = {}
    for cat_name, cat_settings in categories.items():
        lengths = [len(s['display_name']) for s in cat_settings]
        longest_length = max(lengths) if lengths else 0
        
        # Calculate value column position (longest + 2, but within constraints)
        # Reserve first and last character: usable width is 26 chars (28 - 2)
        value_column_pos = longest_length + 2
        if value_column_pos < 12:
            value_column_pos = 12  # Minimum space for names
        if value_column_pos > 22:  # Leave at least 4 chars for values (26 - 22 = 4)
            value_column_pos = 22
            
        category_info[cat_name] = {
            'longest_name': longest_length,
            'value_column_pos': value_column_pos,
            'setting_count': len(cat_settings),
            'longest_examples': sorted(cat_settings, key=lambda x: len(x['display_name']), reverse=True)[:3]
        }
    
    return category_info

def generate_header_file():
    """Generate C header with pre-computed column positions"""
    category_info = analyze_by_category()
    
    # Map category names to enum values
    cat_enum_map = {
        'CAT_VIDEO_DISPLAY': 0,
        'CAT_AUDIO': 1, 
        'CAT_INPUT_CONTROLLERS': 2,
        'CAT_SYSTEM_BOOT': 3,
        'CAT_NETWORK_STORAGE': 4,
        'CAT_ADVANCED': 5
    }
    
    header_content = '''// Auto-generated column positions for OSD settings menu
// Generated by generate_column_positions.py

#ifndef __MENU_COLUMN_POSITIONS_H__
#define __MENU_COLUMN_POSITIONS_H__

// Pre-computed value column positions for each category
// Based on longest setting name + 2 chars, constrained to usable width (26 chars)
static const int category_value_column_pos[] = {
'''
    
    # Create array indexed by category enum
    positions = [12] * 6  # Default minimum position
    for cat_name, info in category_info.items():
        if cat_name in cat_enum_map:
            positions[cat_enum_map[cat_name]] = info['value_column_pos']
    
    for i, pos in enumerate(positions):
        cat_names = ['VIDEO_DISPLAY', 'AUDIO', 'INPUT_CONTROLLERS', 'SYSTEM_BOOT', 'NETWORK_STORAGE', 'ADVANCED']
        header_content += f'    {pos}, // CAT_{cat_names[i]}\n'
    
    header_content += '''};

// Longest setting name length per category (for reference)
static const int category_longest_name[] = {
'''
    
    lengths = [0] * 6
    for cat_name, info in category_info.items():
        if cat_name in cat_enum_map:
            lengths[cat_enum_map[cat_name]] = info['longest_name']
    
    for i, length in enumerate(lengths):
        cat_names = ['VIDEO_DISPLAY', 'AUDIO', 'INPUT_CONTROLLERS', 'SYSTEM_BOOT', 'NETWORK_STORAGE', 'ADVANCED']
        header_content += f'    {length}, // CAT_{cat_names[i]}\n'
    
    header_content += '''};

#endif // __MENU_COLUMN_POSITIONS_H__

/* Analysis Results:
'''
    
    # Add analysis comments
    for cat_name, info in sorted(category_info.items()):
        header_content += f'''
{cat_name}:
  OSD menu settings: {info['setting_count']}
  Longest setting name: {info['longest_name']} chars
  Value column position: {info['value_column_pos']}
  Top longest names:
'''
        for example in info['longest_examples']:
            header_content += f'    {len(example["display_name"]):2d}: "{example["display_name"]}"\n'
    
    header_content += '\n*/'
    
    return header_content

def main():
    # Generate analysis
    print("Analyzing ini_vars array...")
    category_info = analyze_by_category()
    
    print("\nCategory Analysis:")
    print("=" * 50)
    
    for cat_name, info in sorted(category_info.items()):
        print(f"\n{cat_name}:")
        print(f"  OSD menu settings: {info['setting_count']}")
        print(f"  Longest name: {info['longest_name']} chars")
        print(f"  Value column position: {info['value_column_pos']}")
        print(f"  Top 3 longest names:")
        for example in info['longest_examples']:
            print(f"    {len(example['display_name']):2d}: \"{example['display_name']}\"")
    
    # Generate header file
    print("\nGenerating header file...")
    header_content = generate_header_file()
    
    with open('/mnt/c/Users/Robot/Documents/GitHub/Main_MiSTer-misteraddons/menu_column_positions.h', 'w') as f:
        f.write(header_content)
    
    print("Generated: menu_column_positions.h")

if __name__ == "__main__":
    main()